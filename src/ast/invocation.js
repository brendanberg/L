/*
    Invocation AST node
 */

const { Map, List, Record } = require('immutable');
const Value = require('./value');
const Bottom = require('./bottom');
const ASTList = require('./list');
const Evaluate = require('./evaluate');
const { NameError, NotImplemented } = require('../error');

const _ = null;
const _map = Map({});
const _list = List([]);


let Invocation = Record({target: _, plist: _list, tags: _map}, 'Invocation');

Invocation.prototype.toString = function () {
    return this.target.toString() + '(' + this.plist.map(function(it) {
        return it.toString();
    }).toArray().join(', ') + ')';
};

Invocation.prototype.repr = function(depth, style) {
    return this.target.repr(depth, style) + style.delimiter('(') +
        this.plist.map(function(it) {
            return it.repr(depth, style);
        }).toArray().join(style.delimiter(', ')) + style.delimiter(')');
};

Invocation.prototype.eval = function(ctx) {
	let target = this.target.eval(ctx);

	// This is a method invocation LOL
	// Take the selector keys and string em together.
	// Dispatch will select on the type signature so get that right
	// when you define the ctx
	// > Thing :: << Text s >>
	// > Thing t (reverse.) -> { t.s(reverse.) }
	// > t :: Thing(s: "stressed")
	// > t(reverse.)
	// 'desserts'

	var selector = '(' + this.plist.map(function(x) {
		if (x._name === 'KeyValuePair') {
			if (x.key._name === 'Identifier') {
				return x.key.label + ':';
			} else if (x.key._name === 'Operator') {
				return "'" + x.key.label + "':";
			}
		} else if (x._name === 'Qualifier') {
			return '.' + x.label;
		} else {
			// TODO: Evaluate whether we really need this block
			if (x._name === 'Identifier') {
				return x.label;
			} else if (x._name === 'Operator') {
				return "'" + x.label + "'";
			}
		}
	}).join('') + ')';

	// Invocations on Records instantiate a value with field values
	// mapped to named parameters in the message
	if (target._name === 'Record') {
		let value = new Value({
			label: target.label,
			fields: Map(this.plist.map(function(kvp) {
				return [kvp.key.label, kvp.val.eval(ctx)];
			}))
		});
		//ctx.register(value.label, value);
		return value;
	}

	let method;
	
	if (target._name === 'Value') {
		// TODO: When do you invoke a value?
		// A Value's label is an identifier, so you need to use target.label.label
		method = ctx.lookup(target.label).methodForSelector(selector);
	} else if (target._name === 'Variant') {
		method = ctx.lookup(target.getIn(['tags', 'type'])).methodForSelector(selector);
	} else {
		method = ctx.lookup(target._name).methodForSelector(selector);
	}

	if (method && typeof method === 'function') {
		// The selector is implemented as a built-in function.

		let params = this.plist.filter(function (x) {
			return x._name === 'KeyValuePair';
		}).map(function(x) {
			return x.val.eval(ctx);
		}).toArray();

		// Nasty hack to get method invocations to work within method built-ins
		if (!target.has('ctx')) { target.ctx = ctx };
		return method.apply(target, params) || new Bottom();

	} else if (method && method._name === 'Function') {
		// The selector is implemented as a function generated by evaluating
		// a method declaration

		let impl = method.eval(ctx);

		let args = new ASTList({items: this.plist.filter(function (x) {
			return x._name == 'KeyValuePair';
		}).map(function(x) {
			return x.val.eval(ctx);
		}).insert(0, target)});

		let context = impl.ctx.extend(impl.template.match, args);

		if (context) {
			let ret = (new Evaluate({target: impl.block}));
			return ret.eval(context);
		} else {
			return new Bottom();
		}
	} else {
		var msg = (
			"'" + target.toString() + "' does not have a method " +
			"matching the selector '" + selector + "'"
		);
		throw new NameError(msg);
	}
};

Invocation.prototype.transform = function(xform) {
	return xform(this.update('target', function(target) {
		return (target && 'transform' in target) ? target.transform(xform) : xform(target);
	}).update('plist', function(plist) {
		return plist.map(function(item) {
			if (item._name === 'KeyValuePair') {
				return item.update('val', function(val) {
					return (val && 'transform' in val) ? val.transform(xform) : xform(val);
				});
			} else {
				return (item && 'transform' in item) ? item.transform(xform) : xform(item);
			}
		});
	}));
};

module.exports = Invocation;
